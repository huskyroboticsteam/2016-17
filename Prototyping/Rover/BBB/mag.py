# from Adafruit_I2C import Adafruit_I2C
import BNO055
import sys
import threading
import math
import time


class Magnetometer:
    """
    Gets the orientation of the rover by using the BNO055.
    Requires that calibration data generated by calibration_save.py already exists.

    Attributes:
        bno055 (BNO055.BNO055): The object representing the BNO055 hardware.
        current_heading (float): The current heading of the in rover degrees.
            Updated by updater_thread.
        lock (threading.Lock): The lock protecting the current_heading attribute
        updater_thread (_MagnetometerUpdaterThread): The thread that periodically
            updates current_heading.
    """
    def __init__(self):
        self.bno055 = BNO055.BNO055()
        if not self.bno055.begin():
            print 'Cannot initialize BNO055'
            sys.exit()
        with open('calibration_data.txt', 'r') as f:
            self.bno055.set_calibration(map(int, f.read().split(' ')))
        self.current_heading = 0.0
        self.lock = threading.Lock()
        self.updater_thread = _MagnetometerUpdaterThread(self)
        self.updater_thread.start()

    def read(self):
        """
        Returns the current heading of the rover in degrees

        Returns:
            float: The current heading of the rover in degrees. For example,
            0.0 means the rover is facing north. 90.0 means the rover is
            facing east.
            Always between 0.0 and 360.0
        """
        with self.lock:
            return self.current_heading

    # Old magnetometer code, kept just in case

    # def __init__(self):
    #     address = 0x28
    #     self.i2c = Adafruit_I2C(address, -2)
    #     time.sleep(1)

    #     chip_id = self.i2c.readU8(0x00)
    #     print "chipID:  " + str(chip_id)
    #     time.sleep(1)

    #     self.i2c.write8(0x3D, 0x09)
    #     time.sleep(1)

    # # returns the heading data or -1 if an error occurs
    # def read(self):
    #     print "Beginning read"
    #     try:
    #         data = self.i2c.readList(0x1A, 6)
    #         self.hData = data[1] * 256 + data[0]
    #         self.rData = data[3] * 256 + data[2]
    #         self.pData = data[5] * 256 + data[4]
    #         return self.hData / 16.0
    #     except RuntimeError:
    #         return -1


class _MagnetometerUpdaterThread(threading.Thread):
    """
    The thread that periodically updates the current_heading attribute for the
    Magnetometer class. Calculates the average of the last few readings of
    headings as a more accurate value for heading.
    Internal use only.

    Attributes:
        daemon (bool): Set to True so the thread is treated by the
            `threading.Thread` class as a daemon thread.
        magnetometer (Magnetometer): The Magnetometer object that is updated.
        heading_history (list of float): A list of recent heading readings (in
            degrees), with the latest reading at the end of the list. When the
            length exceeds heading_history_max_length, earlier readings are
            deleted.
        heading_history_max_length (int): The maximum length of
            heading_history.
        update_interval (float): Time interval (in seconds) between each update.
    """
    def __init__(self, magnetometer):
        super(_MagnetometerUpdaterThread, self).__init__()
        self.daemon = True
        self.magnetometer = magnetometer
        self.heading_history = []
        self.heading_history_max_length = 3
        self.update_interval = 0.1

    def run(self):
        while True:
            magnetometer = self.magnetometer.bno055.read_magnetometer()
            unadjusted_heading = math.atan2(magnetometer[1], magnetometer[0])
            self.heading_history.append(unadjusted_heading)
            if len(self.heading_history) > self.heading_history_max_length:
                del self.heading_history[0]
            adjusted_heading = self.average_headings(self.heading_history)
            with self.magnetometer.lock:
                self.magnetometer.current_heading = math.degrees(adjusted_heading) % 360.0
            time.sleep(self.update_interval)

    @staticmethod
    def average_headings(headings):
        """
        Calculates the average value of a list of headings.
        Equivalent to finding the unit vectors in the direction of each
        heading, calculating the average vector, and returning the heading of
        that vector.

        Args:
            headings (list of float): The headings in radians.

        Returns:
            float: The average heading in radians.
        """
        x_sum = 0.0
        y_sum = 0.0
        for theta in headings:
            x_sum += math.cos(theta)
            y_sum += math.sin(theta)
        return math.atan2(y_sum, x_sum)
